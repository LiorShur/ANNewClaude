// Export functionality
export class ExportController {
  constructor(appState) {
    this.appState = appState;
    this.dependencies = {};
  }

  setDependencies(deps) {
    this.dependencies = deps;
  }

  initialize() {
    this.setupExportButtons();
    this.setupFileImport();
  }

  setupExportButtons() {
    const buttons = [
      { id: 'prepareAndExportBtn', handler: () => this.prepareAndExport() },
      { id: 'exportGPXBtn', handler: () => this.exportGPX() },
      { id: 'exportPDFBtn', handler: () => this.exportPDF() }
    ];

    buttons.forEach(({ id, handler }) => {
      const button = document.getElementById(id);
      if (button) {
        button.addEventListener('click', handler);
      }
    });
  }

  setupFileImport() {
    const importFile = document.getElementById('importFile');
    if (importFile) {
      importFile.addEventListener('change', (e) => {
        this.handleFileImport(e);
      });
    }
  }

  async prepareAndExport() {
    const routeData = this.appState.getRouteData();
    if (routeData.length === 0) {
      alert('No route data to export. Start tracking first!');
      return;
    }

    try {
      const exportData = {
        exportDate: new Date().toISOString(),
        totalDistance: this.appState.getTotalDistance(),
        elapsedTime: this.appState.getElapsedTime(),
        route: routeData
      };

      this.downloadJSON(exportData, `route-${Date.now()}.json`);
      alert('Route exported successfully!');
    } catch (error) {
      console.error('Export failed:', error);
      alert('Export failed: ' + error.message);
    }
  }

  exportGPX() {
    const routeData = this.appState.getRouteData();
    const locationPoints = routeData.filter(point => point.type === 'location' && point.coords);
    
    if (locationPoints.length === 0) {
      alert('No GPS points to export to GPX!');
      return;
    }

    try {
      const gpxContent = this.generateGPX(locationPoints);
      this.downloadFile(gpxContent, `route-${Date.now()}.gpx`, 'application/gpx+xml');
      alert('GPX file exported successfully!');
    } catch (error) {
      console.error('GPX export failed:', error);
      alert('GPX export failed: ' + error.message);
    }
  }

  exportPDF() {
    if (!window.jsPDF) {
      alert('PDF export not available. jsPDF library required.');
      return;
    }

    const routeData = this.appState.getRouteData();
    if (routeData.length === 0) {
      alert('No route data to export to PDF!');
      return;
    }

    try {
      const { jsPDF } = window.jsPDF;
      const doc = new jsPDF();

      doc.setFontSize(20);
      doc.text('Access Nature - Route Report', 20, 30);

      doc.setFontSize(12);
      doc.text(`Export Date: ${new Date().toLocaleDateString()}`, 20, 45);

      let yPos = 60;
      doc.setFontSize(14);
      doc.text('Route Statistics:', 20, yPos);
      yPos += 15;
      
      doc.setFontSize(12);
      doc.text(`Total Distance: ${this.appState.getTotalDistance().toFixed(2)} km`, 20, yPos);
      yPos += 10;
      doc.text(`Duration: ${this.formatDuration(this.appState.getElapsedTime())}`, 20, yPos);
      yPos += 10;
      doc.text(`GPS Points: ${routeData.filter(p => p.type === 'location').length}`, 20, yPos);
      yPos += 10;
      doc.text(`Photos: ${routeData.filter(p => p.type === 'photo').length}`, 20, yPos);
      yPos += 10;
      doc.text(`Notes: ${routeData.filter(p => p.type === 'text').length}`, 20, yPos);

      doc.save(`route-report-${Date.now()}.pdf`);
      alert('PDF report generated successfully!');

    } catch (error) {
      console.error('PDF export failed:', error);
      alert('PDF export failed: ' + error.message);
    }
  }

  generateGPX(locationPoints) {
    let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="Access Nature" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>Access Nature Route</name>
    <desc>Generated by Access Nature App</desc>
    <time>${new Date().toISOString()}</time>
  </metadata>
  <trk>
    <name>Route Track</name>
    <trkseg>`;

    locationPoints.forEach(point => {
      const timestamp = new Date(point.timestamp).toISOString();
      gpx += `
      <trkpt lat="${point.coords.lat}" lon="${point.coords.lng}">
        <time>${timestamp}</time>
      </trkpt>`;
    });

    gpx += `
    </trkseg>
  </trk>
</gpx>`;

    return gpx;
  }

  formatDuration(milliseconds) {
    const totalSeconds = Math.floor(milliseconds / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  }

  async handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      const fileType = file.name.toLowerCase().split('.').pop();
      
      if (fileType === 'json') {
        await this.importJSON(file);
      } else if (fileType === 'gpx') {
        await this.importGPX(file);
      } else {
        throw new Error('Unsupported file type. Please use .json or .gpx files.');
      }
      
    } catch (error) {
      console.error('Import failed:', error);
      alert('Import failed: ' + error.message);
    }

    event.target.value = '';
  }

  async importJSON(file) {
    const text = await this.readFileAsText(file);
    const data = JSON.parse(text);

    if (!data.route || !Array.isArray(data.route)) {
      throw new Error('Invalid JSON format');
    }

    const shouldClear = this.appState.getRouteData().length > 0 ? 
      confirm('Clear current route data before importing?') : true;

    if (shouldClear) {
      this.appState.clearRouteData();
    }

    data.route.forEach(point => {
      this.appState.addRoutePoint(point);
    });

    alert(`Successfully imported ${data.route.length} data points!`);
  }

  async importGPX(file) {
    const text = await this.readFileAsText(file);
    const parser = new DOMParser();
    const gpxDoc = parser.parseFromString(text, 'text/xml');

    const trackPoints = gpxDoc.querySelectorAll('trkpt');
    if (trackPoints.length === 0) {
      throw new Error('No track points found in GPX file');
    }

    const shouldClear = this.appState.getRouteData().length > 0 ? 
      confirm('Clear current route data before importing?') : true;

    if (shouldClear) {
      this.appState.clearRouteData();
    }

    let importedPoints = 0;
    trackPoints.forEach(trkpt => {
      const lat = parseFloat(trkpt.getAttribute('lat'));
      const lon = parseFloat(trkpt.getAttribute('lon'));
      
      if (isNaN(lat) || isNaN(lon)) return;

      const timeElement = trkpt.querySelector('time');
      
      const point = {
        type: 'location',
        coords: { lat, lng: lon },
        timestamp: timeElement ? new Date(timeElement.textContent).getTime() : Date.now() + importedPoints * 1000
      };

      this.appState.addRoutePoint(point);
      importedPoints++;
    });

    alert(`Successfully imported ${importedPoints} GPS points from GPX file!`);
  }

  readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  }

  downloadJSON(data, filename) {
    const jsonString = JSON.stringify(data, null, 2);
    this.downloadFile(jsonString, filename, 'application/json');
  }

  downloadFile(content, filename, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  triggerImport() {
    const importFile = document.getElementById('importFile');
    if (importFile) {
      importFile.click();
    }
  }
}